//##################################################################################################################################
// FV3D - Finite volume solver
// (c) 2020 | Florian Eigentler
//##################################################################################################################################
#include "navier_stokes_private.h"

//##################################################################################################################################
// DEFINES
//----------------------------------------------------------------------------------------------------------------------------------

//##################################################################################################################################
// MACROS
//----------------------------------------------------------------------------------------------------------------------------------

//##################################################################################################################################
// VARIABLES
//----------------------------------------------------------------------------------------------------------------------------------

//##################################################################################################################################
// LOCAL FUNCTIONS
//----------------------------------------------------------------------------------------------------------------------------------

//##################################################################################################################################
// FUNCTIONS
//----------------------------------------------------------------------------------------------------------------------------------


//     function prim_2_con( phi ) result( res )
//         use mod_equation_vars,  only: n_tot_variables
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: phi(n_tot_variables)
//         real                :: res(n_tot_variables)
//         !---------------------------------------------------------------------------------------------------------------------------
//         !---------------------------------------------------------------------------------------------------------------------------

//         res = phi

//         res(IC_RHO_U)   = phi(IP_U) * phi(IC_RHO)               ! rho * u
//         res(IC_RHO_V)   = phi(IP_V) * phi(IC_RHO)               ! rho * v
//         res(IC_RHO_W)   = phi(IP_W) * phi(IC_RHO)               ! rho * w

//         res(IC_RHO_E)   = s_kappa_m1 * phi(IP_P) + &
//             0.5 * dot_product( phi(IP_UVW), res(IC_RHO_UVW) )   ! rho * e

//     end function prim_2_con

//     !###############################################################################################################################
//     !> Convert a conservative variable to a primitive variable
//     !-------------------------------------------------------------------------------------------------------------------------------
//     function con_2_prim( phi ) result( res )
//         use mod_equation_vars,  only: n_tot_variables
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: phi(n_tot_variables)
//         real                :: res(n_tot_variables)
//         !---------------------------------------------------------------------------------------------------------------------------
//         !---------------------------------------------------------------------------------------------------------------------------

//         res = phi

//         res(IP_U)   = phi(IC_RHO_U) / phi(IC_RHO)                       ! u
//         res(IP_V)   = phi(IC_RHO_V) / phi(IC_RHO)                       ! v
//         res(IP_W)   = phi(IC_RHO_W) / phi(IC_RHO)                       ! w

//         res(IP_P)   = kappa_m1 * (phi(IC_RHO_E) - &
//             0.5 * dot_product( phi(IC_RHO_UVW), res(IP_UVW) ))          ! p

//         res(IP_P)   = max( 1.00E-10, res(IP_P) )                        ! pressure must not be negative

//         res(IP_T)   = ig_temperature( res(IP_P), phi(IC_RHO), R_mix )   ! T

//     end function con_2_prim

//     !###############################################################################################################################
//     !> Calculate the ideal gas pressure.
//     !-------------------------------------------------------------------------------------------------------------------------------
//     function ig_pressure( rho, T, R_mix ) result(res)
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: T
//         real,   intent(in)  :: rho
//         real,   intent(in)  :: R_mix
//         real                :: res
//         !---------------------------------------------------------------------------------------------------------------------------
//         !---------------------------------------------------------------------------------------------------------------------------

//         res = rho * R_mix * T

//     end function ig_pressure

//     !###############################################################################################################################
//     !> Calculate the ideal gas density.
//     !-------------------------------------------------------------------------------------------------------------------------------
//     function ig_density( p, T, R_mix ) result(res)
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: p
//         real,   intent(in)  :: T
//         real,   intent(in)  :: R_mix
//         real                :: res
//         !---------------------------------------------------------------------------------------------------------------------------
//         !---------------------------------------------------------------------------------------------------------------------------

//         res = p / (R_mix * T)

//     end function ig_density

//     !###############################################################################################################################
//     !> Calculate the ideal gas temperature.
//     !-------------------------------------------------------------------------------------------------------------------------------
//     function ig_temperature( p, rho, R_mix ) result(res)
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: p
//         real,   intent(in)  :: rho
//         real,   intent(in)  :: R_mix
//         real                :: res
//         !---------------------------------------------------------------------------------------------------------------------------
//         !---------------------------------------------------------------------------------------------------------------------------

//         res = p / ( rho * R_mix)

//     end function ig_temperature

//     !###############################################################################################################################
//     !> Calculate the pressure at boundaries.
//     !-------------------------------------------------------------------------------------------------------------------------------
//     function pressure_riemann( phi ) result( res )
//         use mod_equation_vars,  only: n_tot_variables
//         implicit none
//         !---------------------------------------------------------------------------------------------------------------------------
//         real,   intent(in)  :: phi(n_tot_variables)
//         real                :: res
//         !---------------------------------------------------------------------------------------------------------------------------
//         real    :: c, ar, br
//         !---------------------------------------------------------------------------------------------------------------------------

//         if( phi(IP_U) .le. 0 ) then
//             c   = sqrt( kappa * phi(IP_P) / phi(IC_RHO) )
//             res = phi(IP_P) * max( 1e-4, 1. + 0.5 * kappa_m1 * phi(IP_U) / c )**(2 * kappa * s_kappa_m1)
//         else
//             ar  = 2 * s_kappa_p1 / phi(IP_U)
//             br  = kappa_m1 * s_kappa_p1 * phi(IP_P)
//             res = phi(IP_P) + phi(IP_U) / ar * 0.5 * (phi(IP_U) + sqrt( phi(IP_U)**2 + 4. * ar * (phi(IP_P) + br) ))
//         end if

//     end function pressure_riemann

// end module mod_ns_eos